<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Raw WebGL - Fake Open World Techniques</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        WASD: Move | Mouse: Look<br>
        Techniques: Skybox + Distance Fog + Billboards
    </div>

    <script>
        // ============================================================
        // VERTEX SHADERS
        // ============================================================
        
        // Shader per geometria normale (terreno, oggetti) CON FOG
        const meshVertexShader = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            varying vec3 vNormal;
            varying vec2 vTexCoord;
            varying float vDistance;  // Per fog
            varying vec3 vWorldPos;
            
            void main() {
                vec4 worldPos = uModelMatrix * vec4(aPosition, 1.0);
                vec4 viewPos = uViewMatrix * worldPos;
                gl_Position = uProjectionMatrix * viewPos;
                
                vNormal = normalize(mat3(uModelMatrix) * aNormal);
                vTexCoord = aTexCoord;
                vDistance = length(viewPos.xyz);  // Distanza dalla camera
                vWorldPos = worldPos.xyz;
            }
        `;
        
        // Shader per skybox (no fog, sempre "dietro" a tutto)
        const skyboxVertexShader = `
            attribute vec3 aPosition;
            
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            varying vec3 vTexCoord;
            
            void main() {
                // Rimuovi traslazione dalla view matrix per skybox fisso
                mat4 viewNoTranslation = uViewMatrix;
                viewNoTranslation[3][0] = 0.0;
                viewNoTranslation[3][1] = 0.0;
                viewNoTranslation[3][2] = 0.0;
                
                vec4 pos = uProjectionMatrix * viewNoTranslation * vec4(aPosition, 1.0);
                gl_Position = pos.xyww;  // Trick: z = w per essere sempre al far plane
                vTexCoord = aPosition;
            }
        `;
        
        // Shader per billboards (sempre rivolti verso camera)
        const billboardVertexShader = `
            attribute vec3 aPosition;  // Centro del billboard in world space
            attribute vec2 aOffset;    // Offset locale del vertice (-0.5 a 0.5)
            attribute vec2 aTexCoord;
            
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform float uBillboardSize;
            
            varying vec2 vTexCoord;
            varying float vDistance;
            
            void main() {
                // Estrai right e up vector dalla view matrix
                vec3 right = vec3(uViewMatrix[0][0], uViewMatrix[1][0], uViewMatrix[2][0]);
                vec3 up = vec3(uViewMatrix[0][1], uViewMatrix[1][1], uViewMatrix[2][1]);
                
                // Costruisci posizione billboard che guarda sempre la camera
                vec3 worldPos = aPosition + 
                               right * aOffset.x * uBillboardSize +
                               up * aOffset.y * uBillboardSize;
                
                vec4 viewPos = uViewMatrix * vec4(worldPos, 1.0);
                gl_Position = uProjectionMatrix * viewPos;
                
                vTexCoord = aTexCoord;
                vDistance = length(viewPos.xyz);
            }
        `;
        
        // ============================================================
        // FRAGMENT SHADERS
        // ============================================================
        
        // Shader per geometria normale CON FOG
        const meshFragmentShader = `
            precision mediump float;
            
            varying vec3 vNormal;
            varying vec2 vTexCoord;
            varying float vDistance;
            varying vec3 vWorldPos;
            
            uniform vec3 uLightDir;
            uniform vec3 uFogColor;
            uniform float uFogStart;
            uniform float uFogEnd;
            uniform vec3 uObjectColor;
            
            void main() {
                // Lighting semplice (diffuse)
                float light = max(dot(vNormal, uLightDir), 0.3);  // 0.3 = ambient
                vec3 color = uObjectColor * light;
                
                // FOG LINEARE - la tecnica chiave!
                float fogFactor = clamp((uFogEnd - vDistance) / (uFogEnd - uFogStart), 0.0, 1.0);
                color = mix(uFogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Shader per skybox (gradient procedurale semplice)
        const skyboxFragmentShader = `
            precision mediump float;
            
            varying vec3 vTexCoord;
            
            void main() {
                // Skybox gradient procedurale: blu sopra, arancione orizzonte, più chiaro sotto
                float t = normalize(vTexCoord).y;
                
                vec3 skyColor = vec3(0.5, 0.7, 1.0);      // Blu cielo
                vec3 horizonColor = vec3(0.9, 0.7, 0.5);  // Arancione orizzonte
                vec3 groundColor = vec3(0.6, 0.6, 0.7);   // Grigio-azzurro sotto
                
                vec3 color;
                if (t > 0.0) {
                    color = mix(horizonColor, skyColor, t);
                } else {
                    color = mix(horizonColor, groundColor, -t);
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Shader per billboards con alpha test
        const billboardFragmentShader = `
            precision mediump float;
            
            varying vec2 vTexCoord;
            varying float vDistance;
            
            uniform vec3 uFogColor;
            uniform float uFogStart;
            uniform float uFogEnd;
            
            void main() {
                // Texture procedurale per albero (cerchio semplice)
                vec2 center = vTexCoord - 0.5;
                float dist = length(center);
                
                // Forma albero: cerchio verde con trasparenza
                if (dist > 0.4) discard;  // Alpha test invece di blending
                
                vec3 treeColor = vec3(0.2, 0.6, 0.2);
                
                // Applica fog anche ai billboards
                float fogFactor = clamp((uFogEnd - vDistance) / (uFogEnd - uFogStart), 0.0, 1.0);
                vec3 color = mix(uFogColor, treeColor, fogFactor);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // ============================================================
        // SETUP WEBGL
        // ============================================================
        
        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }
        
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        
        // ============================================================
        // COMPILE SHADERS - Pattern da replicare in C/Rust
        // ============================================================
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        // Crea i 3 shader programs
        const meshProgram = createProgram(gl, meshVertexShader, meshFragmentShader);
        const skyboxProgram = createProgram(gl, skyboxVertexShader, skyboxFragmentShader);
        const billboardProgram = createProgram(gl, billboardVertexShader, billboardFragmentShader);
        
        // ============================================================
        // GEOMETRIE - Esempi base da replicare
        // ============================================================
        
        // Crea terreno (piano grande)
        function createGroundMesh() {
            const size = 200;
            const vertices = new Float32Array([
                -size, 0, -size,  0, 1, 0,  0, 0,
                 size, 0, -size,  0, 1, 0,  1, 0,
                 size, 0,  size,  0, 1, 0,  1, 1,
                -size, 0,  size,  0, 1, 0,  0, 1,
            ]);
            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            return { vbo, ibo, indexCount: indices.length };
        }
        
        // Crea skybox (cubo)
        function createSkyboxMesh() {
            const vertices = new Float32Array([
                -1, -1, -1,  1, -1, -1,  1,  1, -1, -1,  1, -1,  // Back
                -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,  // Front
                -1, -1, -1, -1,  1, -1, -1,  1,  1, -1, -1,  1,  // Left
                 1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  // Right
                -1,  1, -1,  1,  1, -1,  1,  1,  1, -1,  1,  1,  // Top
                -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,  // Bottom
            ]);
            const indices = new Uint16Array([
                0,1,2, 0,2,3,   4,5,6, 4,6,7,   8,9,10, 8,10,11,
                12,13,14, 12,14,15,   16,17,18, 16,18,19,   20,21,22, 20,22,23
            ]);
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            return { vbo, ibo, indexCount: indices.length };
        }
        
        // Crea billboards per "alberi" - TECNICA CHIAVE
        function createBillboards(count) {
            // Ogni billboard: position(3) + offset(2) + texCoord(2)
            const data = [];
            
            for (let i = 0; i < count; i++) {
                // Posizione random nel mondo
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                const y = 0;
                
                // 4 vertici per quad (2 triangoli)
                // Ogni vertice: position, offset, texCoord
                const positions = [
                    [x, y, z, -0.5, 0.0, 0, 0],
                    [x, y, z,  0.5, 0.0, 1, 0],
                    [x, y, z,  0.5, 1.0, 1, 1],
                    [x, y, z, -0.5, 1.0, 0, 1],
                ];
                
                data.push(...positions[0], ...positions[1], ...positions[2]);
                data.push(...positions[0], ...positions[2], ...positions[3]);
            }
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
            
            return { vbo, vertexCount: count * 6 };
        }
        
        // Crea mesh cards per montagne lontane - altra TECNICA CHIAVE
        function createDistantMountains() {
            const mountains = [];
            const distance = 150;
            
            // 4 piani con "montagne" ai bordi
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Piano verticale orientato verso centro
                const width = 100;
                const height = 30;
                
                // Calcola right vector (perpendicolare alla direzione)
                const right = [-Math.sin(angle), 0, Math.cos(angle)];
                
                const vertices = [];
                // 4 vertici del piano
                for (let v of [
                    [x - right[0] * width/2, 0, z - right[2] * width/2],
                    [x + right[0] * width/2, 0, z + right[2] * width/2],
                    [x + right[0] * width/2, height, z + right[2] * width/2],
                    [x - right[0] * width/2, height, z - right[2] * width/2],
                ]) {
                    vertices.push(...v, 0, 1, 0, 0, 0);  // pos, normal, uv
                }
                
                mountains.push(...vertices);
            }
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mountains), gl.STATIC_DRAW);
            
            const indices = new Uint16Array([
                0,1,2, 0,2,3,   4,5,6, 4,6,7,   8,9,10, 8,10,11,   12,13,14, 12,14,15
            ]);
            
            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            return { vbo, ibo, indexCount: indices.length };
        }
        
        const groundMesh = createGroundMesh();
        const skyboxMesh = createSkyboxMesh();
        const billboards = createBillboards(100);
        const mountains = createDistantMountains();
        
        // ============================================================
        // MATH UTILS - Da replicare in C con glm o simili
        // ============================================================
        
        function mat4Create() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }
        
        function mat4LookAt(eye, center, up) {
            const z = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];
            const zlen = Math.sqrt(z[0]*z[0] + z[1]*z[1] + z[2]*z[2]);
            z[0] /= zlen; z[1] /= zlen; z[2] /= zlen;
            
            const x = [
                up[1] * z[2] - up[2] * z[1],
                up[2] * z[0] - up[0] * z[2],
                up[0] * z[1] - up[1] * z[0]
            ];
            const xlen = Math.sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
            x[0] /= xlen; x[1] /= xlen; x[2] /= xlen;
            
            const y = [
                z[1] * x[2] - z[2] * x[1],
                z[2] * x[0] - z[0] * x[2],
                z[0] * x[1] - z[1] * x[0]
            ];
            
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -(x[0]*eye[0] + x[1]*eye[1] + x[2]*eye[2]),
                -(y[0]*eye[0] + y[1]*eye[1] + y[2]*eye[2]),
                -(z[0]*eye[0] + z[1]*eye[1] + z[2]*eye[2]),
                1
            ]);
        }
        
        // ============================================================
        // CAMERA & INPUT
        // ============================================================
        
        const camera = {
            pos: [0, 5, 10],
            yaw: 0,
            pitch: 0,
            forward: [0, 0, -1],
            right: [1, 0, 0]
        };
        
        const input = {
            forward: false,
            back: false,
            left: false,
            right: false
        };
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w') input.forward = true;
            if (e.key === 's') input.back = true;
            if (e.key === 'a') input.left = true;
            if (e.key === 'd') input.right = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'w') input.forward = false;
            if (e.key === 's') input.back = false;
            if (e.key === 'a') input.left = false;
            if (e.key === 'd') input.right = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
                camera.yaw -= e.movementX * 0.002;
                camera.pitch -= e.movementY * 0.002;
                camera.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.pitch));
            }
        });
        
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });
        
        function updateCamera(dt) {
            // Aggiorna direzioni
            camera.forward = [
                Math.cos(camera.pitch) * Math.sin(camera.yaw),
                Math.sin(camera.pitch),
                Math.cos(camera.pitch) * Math.cos(camera.yaw)
            ];
            camera.right = [
                Math.sin(camera.yaw - Math.PI/2),
                0,
                Math.cos(camera.yaw - Math.PI/2)
            ];
            
            // Movimento
            const speed = 20 * dt;
            if (input.forward) {
                camera.pos[0] += camera.forward[0] * speed;
                camera.pos[2] += camera.forward[2] * speed;
            }
            if (input.back) {
                camera.pos[0] -= camera.forward[0] * speed;
                camera.pos[2] -= camera.forward[2] * speed;
            }
            if (input.left) {
                camera.pos[0] -= camera.right[0] * speed;
                camera.pos[2] -= camera.right[2] * speed;
            }
            if (input.right) {
                camera.pos[0] += camera.right[0] * speed;
                camera.pos[2] += camera.right[2] * speed;
            }
        }
        
        // ============================================================
        // RENDER LOOP
        // ============================================================
        
        const projectionMatrix = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
        const modelMatrix = mat4Create();
        
        // FOG SETTINGS - PARAMETRI CHIAVE
        const fogColor = [0.7, 0.8, 0.9];  // Colore fog (simile a skybox)
        const fogStart = 30.0;
        const fogEnd = 120.0;
        
        let lastTime = 0;
        function render(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;
            
            updateCamera(dt);
            
            const center = [
                camera.pos[0] + camera.forward[0],
                camera.pos[1] + camera.forward[1],
                camera.pos[2] + camera.forward[2]
            ];
            const viewMatrix = mat4LookAt(camera.pos, center, [0, 1, 0]);
            
            gl.clearColor(...fogColor, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // 1. Render SKYBOX (sempre per primo, no depth write)
            gl.depthMask(false);
            gl.useProgram(skyboxProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, skyboxMesh.vbo);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, skyboxMesh.ibo);
            
            const skyPosLoc = gl.getAttribLocation(skyboxProgram, 'aPosition');
            gl.enableVertexAttribArray(skyPosLoc);
            gl.vertexAttribPointer(skyPosLoc, 3, gl.FLOAT, false, 12, 0);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(skyboxProgram, 'uViewMatrix'), false, viewMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(skyboxProgram, 'uProjectionMatrix'), false, projectionMatrix);
            
            gl.drawElements(gl.TRIANGLES, skyboxMesh.indexCount, gl.UNSIGNED_SHORT, 0);
            gl.depthMask(true);
            
            // 2. Render TERRENO con fog
            gl.useProgram(meshProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, groundMesh.vbo);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundMesh.ibo);
            
            const meshPosLoc = gl.getAttribLocation(meshProgram, 'aPosition');
            const meshNormLoc = gl.getAttribLocation(meshProgram, 'aNormal');
            const meshTexLoc = gl.getAttribLocation(meshProgram, 'aTexCoord');
            
            gl.enableVertexAttribArray(meshPosLoc);
            gl.enableVertexAttribArray(meshNormLoc);
            gl.enableVertexAttribArray(meshTexLoc);
            
            gl.vertexAttribPointer(meshPosLoc, 3, gl.FLOAT, false, 32, 0);
            gl.vertexAttribPointer(meshNormLoc, 3, gl.FLOAT, false, 32, 12);
            gl.vertexAttribPointer(meshTexLoc, 2, gl.FLOAT, false, 32, 24);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(meshProgram, 'uModelMatrix'), false, modelMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(meshProgram, 'uViewMatrix'), false, viewMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(meshProgram, 'uProjectionMatrix'), false, projectionMatrix);
            gl.uniform3f(gl.getUniformLocation(meshProgram, 'uLightDir'), 0.5, 0.7, 0.3);
            gl.uniform3fv(gl.getUniformLocation(meshProgram, 'uFogColor'), fogColor);
            gl.uniform1f(gl.getUniformLocation(meshProgram, 'uFogStart'), fogStart);
            gl.uniform1f(gl.getUniformLocation(meshProgram, 'uFogEnd'), fogEnd);
            gl.uniform3f(gl.getUniformLocation(meshProgram, 'uObjectColor'), 0.4, 0.5, 0.3);
            
            gl.drawElements(gl.TRIANGLES, groundMesh.indexCount, gl.UNSIGNED_SHORT, 0);
            
            // 3. Render MONTAGNE LONTANE (mesh cards)
            gl.bindBuffer(gl.ARRAY_BUFFER, mountains.vbo);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mountains.ibo);
            
            gl.vertexAttribPointer(meshPosLoc, 3, gl.FLOAT, false, 32, 0);
            gl.vertexAttribPointer(meshNormLoc, 3, gl.FLOAT, false, 32, 12);
            gl.vertexAttribPointer(meshTexLoc, 2, gl.FLOAT, false, 32, 24);
            
            gl.uniform3f(gl.getUniformLocation(meshProgram, 'uObjectColor'), 0.3, 0.35, 0.5);
            gl.drawElements(gl.TRIANGLES, mountains.indexCount, gl.UNSIGNED_SHORT, 0);
            
            // 4. Render BILLBOARDS (alberi)
            gl.useProgram(billboardProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, billboards.vbo);
            
            const billPosLoc = gl.getAttribLocation(billboardProgram, 'aPosition');
            const billOffsetLoc = gl.getAttribLocation(billboardProgram, 'aOffset');
            const billTexLoc = gl.getAttribLocation(billboardProgram, 'aTexCoord');
            
            gl.enableVertexAttribArray(billPosLoc);
            gl.enableVertexAttribArray(billOffsetLoc);
            gl.enableVertexAttribArray(billTexLoc);
            
            gl.vertexAttribPointer(billPosLoc, 3, gl.FLOAT, false, 28, 0);
            gl.vertexAttribPointer(billOffsetLoc, 2, gl.FLOAT, false, 28, 12);
            gl.vertexAttribPointer(billTexLoc, 2, gl.FLOAT, false, 28, 20);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(billboardProgram, 'uViewMatrix'), false, viewMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(billboardProgram, 'uProjectionMatrix'), false, projectionMatrix);
            gl.uniform1f(gl.getUniformLocation(billboardProgram, 'uBillboardSize'), 8.0);
            gl.uniform3fv(gl.getUniformLocation(billboardProgram, 'uFogColor'), fogColor);
            gl.uniform1f(gl.getUniformLocation(billboardProgram, 'uFogStart'), fogStart);
            gl.uniform1f(gl.getUniformLocation(billboardProgram, 'uFogEnd'), fogEnd);
            
            gl.drawArrays(gl.TRIANGLES, 0, billboards.vertexCount);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
        
        // ============================================================
        // NOTE PER TRADUZIONE IN C/RUST:
        // ============================================================
        // 
        // 1. SHADERS: Identici, solo caricamento da file invece che string
        // 2. BUFFER: gl.createBuffer() → glGenBuffers(), etc
        // 3. MATH: Usa glm (C++) o nalgebra/cgmath (Rust)
        // 4. WINDOW: SDL2 o GLFW per input e window management
        // 5. STRUTTURA: Stessa logica, solo sintassi diversa
        //
        // Rust example equivalente:
        // let vbo = gl.gen_buffers(1)[0];
        // gl.bind_buffer(glow::ARRAY_BUFFER, Some(vbo));
        // gl.buffer_data_u8_slice(glow::ARRAY_BUFFER, &vertices, glow::STATIC_DRAW);
        //
        // LE TECNICHE (fog, billboards, mesh cards) sono identiche!
        // ============================================================
        
    </script>
</body>
</html>
